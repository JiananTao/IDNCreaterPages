{"version":3,"file":"js/211.ff117a97.js","mappings":"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","sources":["webpack://IDNCreaterPages/./node_modules/@khanacademy/simple-markdown/dist/es/index.js","webpack://IDNCreaterPages/./node_modules/mermaid/dist/createText-1f5f8f92.js"],"sourcesContent":["/* eslint-disable prefer-spread, no-regex-spaces, no-unused-vars, guard-for-in, no-console, no-var */\n\n/**\n * Simple-Markdown\n * ===============\n *\n * Simple-Markdown's primary goal is to be easy to adapt. It aims\n * to be compliant with John Gruber's [Markdown Syntax page][1],\n * but compatiblity with other markdown implementations' edge-cases\n * will be sacrificed where it conflicts with simplicity or\n * extensibility.\n *\n * If your goal is to simply embed a standard markdown implementation\n * in your website, simple-markdown is probably not the best library\n * for you (although it should work). But if you have struggled to\n * customize an existing library to meet your needs, simple-markdown\n * might be able to help.\n *\n * Many of the regexes and original logic has been adapted from\n * the wonderful [marked.js](https://github.com/chjj/marked)\n */\n// Flow Type Definitions:\n// We want to clarify our defaultRules types a little bit more so clients can\n// reuse defaultRules built-ins. So we make some stronger guarantess when\n// we can:\n// End Flow Definitions\nvar CR_NEWLINE_R = /\\r\\n?/g;\nvar TAB_R = /\\t/g;\nvar FORMFEED_R = /\\f/g;\n/**\n * Turn various whitespace into easy-to-process whitespace\n */\n\nvar preprocess = function preprocess(source) {\n  return source.replace(CR_NEWLINE_R, \"\\n\").replace(FORMFEED_R, \"\").replace(TAB_R, \"    \");\n};\n\nvar populateInitialState = function populateInitialState(givenState, defaultState) {\n  var state = givenState || {};\n\n  if (defaultState != null) {\n    for (var prop in defaultState) {\n      // $FlowFixMe\n      if (Object.prototype.hasOwnProperty.call(defaultState, prop)) {\n        state[prop] = defaultState[prop];\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @param {SimpleMarkdown.ParserRules} rules\n *     an object containing\n *     rule type -> {match, order, parse} objects\n *     (lower order is higher precedence)\n * @param {SimpleMarkdown.OptionalState} [defaultState]\n *\n * @returns {SimpleMarkdown.Parser}\n *     The resulting parse function, with the following parameters:\n *     @source: the input source string to be parsed\n *     @state: an optional object to be threaded through parse\n *         calls. Allows clients to add stateful operations to\n *         parsing, such as keeping track of how many levels deep\n *         some nesting is. For an example use-case, see passage-ref\n *         parsing in src/widgets/passage/passage-markdown.jsx\n */\n\n\nvar parserFor = function parserFor(rules, defaultState) {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  var ruleList = Object.keys(rules).filter(function (type) {\n    var rule = rules[type];\n\n    if (rule == null || rule.match == null) {\n      return false;\n    }\n\n    var order = rule.order;\n\n    if ((typeof order !== \"number\" || !isFinite(order)) && typeof console !== \"undefined\") {\n      console.warn(\"simple-markdown: Invalid order for rule `\" + type + \"`: \" + String(order));\n    }\n\n    return true;\n  });\n  ruleList.sort(function (typeA, typeB) {\n    var ruleA = rules[typeA];\n    var ruleB = rules[typeB];\n    var orderA = ruleA.order;\n    var orderB = ruleB.order; // First sort based on increasing order\n\n    if (orderA !== orderB) {\n      return orderA - orderB;\n    }\n\n    var secondaryOrderA = ruleA.quality ? 0 : 1;\n    var secondaryOrderB = ruleB.quality ? 0 : 1;\n\n    if (secondaryOrderA !== secondaryOrderB) {\n      return secondaryOrderA - secondaryOrderB; // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1;\n    } else if (typeA > typeB) {\n      return 1;\n    } else {\n      // Rules should never have the same name,\n      // but this is provided for completeness.\n      return 0;\n    }\n  });\n  var latestState;\n\n  var nestedParse = function nestedParse(source, state) {\n    var result = [];\n    state = state || latestState;\n    latestState = state;\n\n    while (source) {\n      // store the best match, it's rule, and quality:\n      var ruleType = null;\n      var rule = null;\n      var capture = null;\n      var quality = NaN; // loop control variables:\n\n      var i = 0;\n      var currRuleType = ruleList[0]; // $FlowFixMe\n\n      var currRule = rules[currRuleType];\n\n      do {\n        var currOrder = currRule.order;\n        var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n        var currCapture = currRule.match(source, state, prevCaptureStr);\n\n        if (currCapture) {\n          var currQuality = currRule.quality ? currRule.quality(currCapture, state, prevCaptureStr) : 0; // This should always be true the first time because\n          // the initial quality is NaN (that's why there's the\n          // condition negation).\n\n          if (!(currQuality <= quality)) {\n            ruleType = currRuleType;\n            rule = currRule;\n            capture = currCapture;\n            quality = currQuality;\n          }\n        } // Move on to the next item.\n        // Note that this makes `currRule` be the next item\n\n\n        i++;\n        currRuleType = ruleList[i]; // $FlowFixMe\n\n        currRule = rules[currRuleType];\n      } while ( // keep looping while we're still within the ruleList\n      currRule && ( // if we don't have a match yet, continue\n      !capture || // or if we have a match, but the next rule is\n      // at the same order, and has a quality measurement\n      // functions, then this rule must have a quality\n      // measurement function (since they are sorted before\n      // those without), and we need to check if there is\n      // a better quality match\n      currRule.order === currOrder && currRule.quality)); // TODO(aria): Write tests for these\n\n\n      if (rule == null || capture == null) {\n        throw new Error(\"Could not find a matching rule for the below \" + \"content. The rule with highest `order` should \" + \"always match content provided to it. Check \" + \"the definition of `match` for '\" + ruleList[ruleList.length - 1] + \"'. It seems to not match the following source:\\n\" + source);\n      }\n\n      if (capture.index) {\n        // If present and non-zero, i.e. a non-^ regexp result:\n        throw new Error(\"`match` must return a capture starting at index 0 \" + \"(the current parse index). Did you forget a ^ at the \" + \"start of the RegExp?\");\n      }\n\n      var parsed = rule.parse(capture, nestedParse, state); // We maintain the same object here so that rules can\n      // store references to the objects they return and\n      // modify them later. (oops sorry! but this adds a lot\n      // of power--see reflinks.)\n\n      if (Array.isArray(parsed)) {\n        // $FlowFixMe\n        Array.prototype.push.apply(result, parsed);\n      } else {\n        if (parsed == null || typeof parsed !== \"object\") {\n          throw new Error(\"parse() function returned invalid parse result: '\".concat(parsed, \"'\"));\n        } // We also let rules override the default type of\n        // their parsed node if they would like to, so that\n        // there can be a single output function for all links,\n        // even if there are several rules to parse them.\n\n\n        if (parsed.type == null) {\n          // $FlowFixMe\n          parsed.type = ruleType;\n        }\n\n        result.push(parsed);\n      }\n\n      state.prevCapture = capture;\n      source = source.substring(state.prevCapture[0].length);\n    } // $FlowFixMe\n\n\n    return result;\n  };\n\n  var outerParse = function outerParse(source, state) {\n    latestState = populateInitialState(state, defaultState);\n\n    if (!latestState.inline && !latestState.disableAutoBlockNewlines) {\n      source = source + \"\\n\\n\";\n    } // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information). This stores\n    // the full regex capture object, if there is one.\n\n\n    latestState.prevCapture = null;\n    return nestedParse(preprocess(source), latestState);\n  }; // $FlowFixMe\n\n\n  return outerParse;\n}; // Creates a match function for an inline scoped element from a regex\n\n\nvar inlineRegex = function inlineRegex(regex) {\n  var match = function match(source, state, prevCapture) {\n    if (state.inline) {\n      // $FlowFixMe\n      return regex.exec(source);\n    } else {\n      return null;\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function for a block scoped element from a regex\n\n\nvar blockRegex = function blockRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    if (state.inline) {\n      return null;\n    } else {\n      return regex.exec(source);\n    }\n  };\n\n  match.regex = regex;\n  return match;\n}; // Creates a match function from a regex, ignoring block/inline scope\n\n\nvar anyScopeRegex = function anyScopeRegex(regex) {\n  // $FlowFixMe\n  var match = function match(source, state) {\n    return regex.exec(source);\n  };\n\n  match.regex = regex;\n  return match;\n};\n\nvar TYPE_SYMBOL = typeof Symbol === \"function\" && Symbol.for && Symbol.for(\"react.element\") || 0xeac7;\n\nvar reactElement = function reactElement(type, key, props) {\n  var element = {\n    $$typeof: TYPE_SYMBOL,\n    type: type,\n    key: key == null ? undefined : key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n  return element;\n};\n/** Returns a closed HTML tag.\n * @param {string} tagName - Name of HTML tag (eg. \"em\" or \"a\")\n * @param {string} content - Inner content of tag\n * @param {{ [attr: string]: SimpleMarkdown.Attr }} [attributes] - Optional extra attributes of tag as an object of key-value pairs\n *   eg. { \"href\": \"http://google.com\" }. Falsey attributes are filtered out.\n * @param {boolean} [isClosed] - boolean that controls whether tag is closed or not (eg. img tags).\n *   defaults to true\n */\n\n\nvar htmlTag = function htmlTag(tagName, content, attributes, isClosed) {\n  attributes = attributes || {};\n  isClosed = typeof isClosed !== \"undefined\" ? isClosed : true;\n  var attributeString = \"\";\n\n  for (var attr in attributes) {\n    var attribute = attributes[attr]; // Removes falsey attributes\n\n    if ( // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(attributes, attr) && attribute) {\n      attributeString += \" \" + sanitizeText(attr) + '=\"' + sanitizeText(attribute) + '\"';\n    }\n  }\n\n  var unclosedTag = \"<\" + tagName + attributeString + \">\";\n\n  if (isClosed) {\n    return unclosedTag + content + \"</\" + tagName + \">\";\n  } else {\n    return unclosedTag;\n  }\n};\n\nvar EMPTY_PROPS = {};\n/**\n * @param {string | null | undefined} url - url to sanitize\n * @returns {string | null} - url if safe, or null if a safe url could not be made\n */\n\nvar sanitizeUrl = function sanitizeUrl(url) {\n  if (url == null) {\n    return null;\n  }\n\n  try {\n    var prot = new URL(url, \"https://localhost\").protocol;\n\n    if (prot.indexOf(\"javascript:\") === 0 || prot.indexOf(\"vbscript:\") === 0 || prot.indexOf(\"data:\") === 0) {\n      return null;\n    }\n  } catch (e) {\n    // invalid URLs should throw a TypeError\n    // see for instance: `new URL(\"\");`\n    return null;\n  }\n\n  return url;\n};\n\nvar SANITIZE_TEXT_R = /[<>&\"']/g;\nvar SANITIZE_TEXT_CODES = {\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  \"&\": \"&amp;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"/\": \"&#x2F;\",\n  \"`\": \"&#96;\"\n};\n\nvar sanitizeText = function sanitizeText(text) {\n  return String(text).replace(SANITIZE_TEXT_R, function (chr) {\n    return SANITIZE_TEXT_CODES[chr];\n  });\n};\n\nvar UNESCAPE_URL_R = /\\\\([^0-9A-Za-z\\s])/g;\n\nvar unescapeUrl = function unescapeUrl(rawUrlString) {\n  return rawUrlString.replace(UNESCAPE_URL_R, \"$1\");\n};\n/**\n * Parse some content with the parser `parse`, with state.inline\n * set to true. Useful for block elements; not generally necessary\n * to be used by inline elements (where state.inline is already true.\n */\n\n\nvar parseInline = function parseInline(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = true;\n  var result = parse(content, state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseBlock = function parseBlock(parse, content, state) {\n  var isCurrentlyInline = state.inline || false;\n  state.inline = false;\n  var result = parse(content + \"\\n\\n\", state);\n  state.inline = isCurrentlyInline;\n  return result;\n};\n\nvar parseCaptureInline = function parseCaptureInline(capture, parse, state) {\n  return {\n    content: parseInline(parse, capture[1], state)\n  };\n};\n\nvar ignoreCapture = function ignoreCapture() {\n  return {};\n}; // recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\n\n\nvar LIST_BULLET = \"(?:[*+-]|\\\\d+\\\\.)\"; // recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\n\nvar LIST_ITEM_PREFIX = \"( *)(\" + LIST_BULLET + \") +\";\nvar LIST_ITEM_PREFIX_R = new RegExp(\"^\" + LIST_ITEM_PREFIX); // recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\n\nvar LIST_ITEM_R = new RegExp(LIST_ITEM_PREFIX + \"[^\\\\n]*(?:\\\\n\" + \"(?!\\\\1\" + LIST_BULLET + \" )[^\\\\n]*)*(\\n|$)\", \"gm\");\nvar BLOCK_END_R = /\\n{2,}$/;\nvar INLINE_CODE_ESCAPE_BACKTICKS_R = /^ (?= *`)|(` *) $/g; // recognize the end of a paragraph block inside a list item:\n// two or more newlines at end end of the item\n\nvar LIST_BLOCK_END_R = BLOCK_END_R;\nvar LIST_ITEM_END_R = / *\\n+$/; // check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\n\nvar LIST_R = new RegExp(\"^( *)(\" + LIST_BULLET + \") \" + \"[\\\\s\\\\S]+?(?:\\n{2,}(?! )\" + \"(?!\\\\1\" + LIST_BULLET + \" )\\\\n*\" + // the \\\\s*$ here is so that we can parse the inside of nested\n// lists, where our content might end before we receive two `\\n`s\n\"|\\\\s*\\n*$)\");\nvar LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/;\n\nvar TABLES = function () {\n  var TABLE_ROW_SEPARATOR_TRIM = /^ *\\| *| *\\| *$/g;\n  var TABLE_CELL_END_TRIM = / *$/;\n  var TABLE_RIGHT_ALIGN = /^ *-+: *$/;\n  var TABLE_CENTER_ALIGN = /^ *:-+: *$/;\n  var TABLE_LEFT_ALIGN = /^ *:-+ *$/; // TODO: This needs a real type\n\n  var parseTableAlignCapture = function parseTableAlignCapture(alignCapture) {\n    if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n      return \"right\";\n    } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n      return \"center\";\n    } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n      return \"left\";\n    } else {\n      return null;\n    }\n  };\n\n  var parseTableAlign = function parseTableAlign(source, parse, state, trimEndSeparators) {\n    if (trimEndSeparators) {\n      source = source.replace(TABLE_ROW_SEPARATOR_TRIM, \"\");\n    }\n\n    var alignText = source.trim().split(\"|\");\n    return alignText.map(parseTableAlignCapture);\n  };\n\n  var parseTableRow = function parseTableRow(source, parse, state, trimEndSeparators) {\n    var prevInTable = state.inTable;\n    state.inTable = true;\n    var tableRow = parse(source.trim(), state);\n    state.inTable = prevInTable;\n    var cells = [[]];\n    tableRow.forEach(function (node, i) {\n      if (node.type === \"tableSeparator\") {\n        // Filter out empty table separators at the start/end:\n        if (!trimEndSeparators || i !== 0 && i !== tableRow.length - 1) {\n          // Split the current row:\n          cells.push([]);\n        }\n      } else {\n        if (node.type === \"text\" && (tableRow[i + 1] == null || tableRow[i + 1].type === \"tableSeparator\")) {\n          node.content = node.content.replace(TABLE_CELL_END_TRIM, \"\");\n        }\n\n        cells[cells.length - 1].push(node);\n      }\n    });\n    return cells;\n  };\n  /**\n   * @param {string} source\n   * @param {SimpleMarkdown.Parser} parse\n   * @param {SimpleMarkdown.State} state\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.ASTNode[][]}\n   */\n\n\n  var parseTableCells = function parseTableCells(source, parse, state, trimEndSeparators) {\n    var rowsText = source.trim().split(\"\\n\");\n    return rowsText.map(function (rowText) {\n      // $FlowFixMe\n      return parseTableRow(rowText, parse, state, trimEndSeparators);\n    });\n  };\n  /**\n   * @param {boolean} trimEndSeparators\n   * @returns {SimpleMarkdown.SingleNodeParseFunction}\n   */\n\n\n  var parseTable = function parseTable(trimEndSeparators) {\n    return function (capture, parse, state) {\n      state.inline = true;\n      var header = parseTableRow(capture[1], parse, state, trimEndSeparators);\n      var align = parseTableAlign(capture[2], parse, state, trimEndSeparators);\n      var cells = parseTableCells(capture[3], parse, state, trimEndSeparators);\n      state.inline = false;\n      return {\n        type: \"table\",\n        header: header,\n        align: align,\n        cells: cells\n      };\n    };\n  };\n\n  return {\n    parseTable: parseTable(true),\n    parseNpTable: parseTable(false),\n    TABLE_REGEX: /^ *(\\|.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/,\n    NPTABLE_REGEX: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/\n  };\n}();\n\nvar LINK_INSIDE = \"(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*\";\nvar LINK_HREF_AND_TITLE = \"\\\\s*<?((?:\\\\([^)]*\\\\)|[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+['\\\"]([\\\\s\\\\S]*?)['\\\"])?\\\\s*\";\nvar AUTOLINK_MAILTO_CHECK_R = /mailto:/i;\n\nvar parseRef = function parseRef(capture, state, refNode) {\n  var ref = (capture[2] || capture[1]).replace(/\\s+/g, \" \").toLowerCase(); // We store information about previously seen defs on\n  // state._defs (_ to deconflict with client-defined\n  // state). If the def for this reflink/refimage has\n  // already been seen, we can use its target/source\n  // and title here:\n\n  if (state._defs && state._defs[ref]) {\n    var def = state._defs[ref]; // `refNode` can be a link or an image. Both use\n    // target and title properties.\n\n    refNode.target = def.target;\n    refNode.title = def.title;\n  } // In case we haven't seen our def yet (or if someone\n  // overwrites that def later on), we add this node\n  // to the list of ref nodes for that def. Then, when\n  // we find the def, we can modify this link/image AST\n  // node :).\n  // I'm sorry.\n\n\n  state._refs = state._refs || {};\n  state._refs[ref] = state._refs[ref] || [];\n\n  state._refs[ref].push(refNode);\n\n  return refNode;\n};\n\nvar currOrder = 0;\nvar defaultRules = {\n  Array: {\n    react: function react(arr, output, state) {\n      var oldKey = state.key;\n      var result = []; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0, key = 0; i < arr.length; i++, key++) {\n        // `key` is our numerical `state.key`, which we increment for\n        // every output node, but don't change for joined text nodes.\n        // (i, however, must change for joined text nodes)\n        state.key = \"\" + i;\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result.push(output(node, state));\n      }\n\n      state.key = oldKey;\n      return result;\n    },\n    html: function html(arr, output, state) {\n      var result = \"\"; // map output over the ast, except group any text\n      // nodes together into a single string output.\n\n      for (var i = 0; i < arr.length; i++) {\n        var node = arr[i];\n\n        if (node.type === \"text\") {\n          node = {\n            type: \"text\",\n            content: node.content\n          };\n\n          for (; i + 1 < arr.length && arr[i + 1].type === \"text\"; i++) {\n            node.content += arr[i + 1].content;\n          }\n        }\n\n        result += output(node, state);\n      }\n\n      return result;\n    }\n  },\n  heading: {\n    order: currOrder++,\n    match: blockRegex(/^ *(#{1,6})([^\\n]+?)#* *(?:\\n *)+\\n/),\n    parse: function (_parse) {\n      function parse(_x, _x2, _x3) {\n        return _parse.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        level: capture[1].length,\n        content: parseInline(parse, capture[2].trim(), state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"h\" + node.level, state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"h\" + node.level, output(node.content, state));\n    }\n  },\n  nptable: {\n    order: currOrder++,\n    match: blockRegex(TABLES.NPTABLE_REGEX),\n    parse: TABLES.parseNpTable,\n    react: null,\n    html: null\n  },\n  lheading: {\n    order: currOrder++,\n    match: blockRegex(/^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/),\n    parse: function (_parse2) {\n      function parse(_x4, _x5, _x6) {\n        return _parse2.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse2.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"heading\",\n        level: capture[2] === \"=\" ? 1 : 2,\n        content: parseInline(parse, capture[1], state)\n      };\n    }),\n    react: null,\n    html: null\n  },\n  hr: {\n    order: currOrder++,\n    match: blockRegex(/^( *[-*_]){3,} *(?:\\n *)+\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"hr\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<hr>\";\n    }\n  },\n  codeBlock: {\n    order: currOrder++,\n    match: blockRegex(/^(?:    [^\\n]+\\n*)+(?:\\n *)+\\n/),\n    parse: function (_parse3) {\n      function parse(_x7, _x8, _x9) {\n        return _parse3.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse3.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^    /gm, \"\").replace(/\\n+$/, \"\");\n      return {\n        lang: undefined,\n        content: content\n      };\n    }),\n    react: function react(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      return reactElement(\"pre\", state.key, {\n        children: reactElement(\"code\", null, {\n          className: className,\n          children: node.content\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var className = node.lang ? \"markdown-code-\" + node.lang : undefined;\n      var codeBlock = htmlTag(\"code\", sanitizeText(node.content), {\n        class: className\n      });\n      return htmlTag(\"pre\", codeBlock);\n    }\n  },\n  fence: {\n    order: currOrder++,\n    match: blockRegex(/^ *(`{3,}|~{3,}) *(?:(\\S+) *)?\\n([\\s\\S]+?)\\n?\\1 *(?:\\n *)+\\n/),\n    parse: function (_parse4) {\n      function parse(_x10, _x11, _x12) {\n        return _parse4.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse4.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"codeBlock\",\n        lang: capture[2] || undefined,\n        content: capture[3]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  blockQuote: {\n    order: currOrder++,\n    match: blockRegex(/^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/),\n    parse: function (_parse5) {\n      function parse(_x13, _x14, _x15) {\n        return _parse5.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse5.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var content = capture[0].replace(/^ *> ?/gm, \"\");\n      return {\n        content: parse(content, state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"blockquote\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"blockquote\", output(node.content, state));\n    }\n  },\n  list: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      // We only want to break into a list if we are at the start of a\n      // line. This is to avoid parsing \"hi * there\" with \"* there\"\n      // becoming a part of a list.\n      // You might wonder, \"but that's inline, so of course it wouldn't\n      // start a list?\". You would be correct! Except that some of our\n      // lists can be inline, because they might be inside another list,\n      // in which case we can parse with inline scope, but need to allow\n      // nested lists inside this inline scope.\n      var prevCaptureStr = state.prevCapture == null ? \"\" : state.prevCapture[0];\n      var isStartOfLineCapture = LIST_LOOKBEHIND_R.exec(prevCaptureStr);\n      var isListBlock = state._list || !state.inline;\n\n      if (isStartOfLineCapture && isListBlock) {\n        source = isStartOfLineCapture[1] + source;\n        return LIST_R.exec(source);\n      } else {\n        return null;\n      }\n    },\n    parse: function (_parse6) {\n      function parse(_x16, _x17, _x18) {\n        return _parse6.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse6.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var bullet = capture[2];\n      var ordered = bullet.length > 1;\n      var start = ordered ? +bullet : undefined;\n      var items = capture[0].replace(LIST_BLOCK_END_R, \"\\n\").match(LIST_ITEM_R); // We know this will match here, because of how the regexes are\n      // defined\n\n      var lastItemWasAParagraph = false;\n      var itemContent = items.map(function (item, i) {\n        // We need to see how far indented this item is:\n        var prefixCapture = LIST_ITEM_PREFIX_R.exec(item);\n        var space = prefixCapture ? prefixCapture[0].length : 0; // And then we construct a regex to \"unindent\" the subsequent\n        // lines of the items by that amount:\n\n        var spaceRegex = new RegExp(\"^ {1,\" + space + \"}\", \"gm\"); // Before processing the item, we need a couple things\n\n        var content = item // remove indents on trailing lines:\n        .replace(spaceRegex, \"\") // remove the bullet:\n        .replace(LIST_ITEM_PREFIX_R, \"\"); // I'm not sur4 why this is necessary again?\n        // Handling \"loose\" lists, like:\n        //\n        //  * this is wrapped in a paragraph\n        //\n        //  * as is this\n        //\n        //  * as is this\n\n        var isLastItem = i === items.length - 1;\n        var containsBlocks = content.indexOf(\"\\n\\n\") !== -1; // Any element in a list is a block if it contains multiple\n        // newlines. The last element in the list can also be a block\n        // if the previous item in the list was a block (this is\n        // because non-last items in the list can end with \\n\\n, but\n        // the last item can't, so we just \"inherit\" this property\n        // from our previous element).\n\n        var thisItemIsAParagraph = containsBlocks || isLastItem && lastItemWasAParagraph;\n        lastItemWasAParagraph = thisItemIsAParagraph; // backup our state for restoration afterwards. We're going to\n        // want to set state._list to true, and state.inline depending\n        // on our list's looseness.\n\n        var oldStateInline = state.inline;\n        var oldStateList = state._list;\n        state._list = true; // Parse inline if we're in a tight list, or block if we're in\n        // a loose list.\n\n        var adjustedContent;\n\n        if (thisItemIsAParagraph) {\n          state.inline = false;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\\n\\n\");\n        } else {\n          state.inline = true;\n          adjustedContent = content.replace(LIST_ITEM_END_R, \"\");\n        }\n\n        var result = parse(adjustedContent, state); // Restore our state before returning\n\n        state.inline = oldStateInline;\n        state._list = oldStateList;\n        return result;\n      });\n      return {\n        ordered: ordered,\n        start: start,\n        items: itemContent\n      };\n    }),\n    react: function react(node, output, state) {\n      var ListWrapper = node.ordered ? \"ol\" : \"ul\";\n      return reactElement(ListWrapper, state.key, {\n        start: node.start,\n        children: node.items.map(function (item, i) {\n          return reactElement(\"li\", \"\" + i, {\n            children: output(item, state)\n          });\n        })\n      });\n    },\n    html: function html(node, output, state) {\n      var listItems = node.items.map(function (item) {\n        return htmlTag(\"li\", output(item, state));\n      }).join(\"\");\n      var listTag = node.ordered ? \"ol\" : \"ul\";\n      var attributes = {\n        start: node.start\n      };\n      return htmlTag(listTag, listItems, attributes);\n    }\n  },\n  def: {\n    order: currOrder++,\n    // TODO(aria): This will match without a blank line before the next\n    // block element, which is inconsistent with most of the rest of\n    // simple-markdown.\n    match: blockRegex(/^ *\\[([^\\]]+)\\]: *<?([^\\s>]*)>?(?: +[\"(]([^\\n]+)[\")])? *\\n(?: *\\n)*/),\n    parse: function (_parse7) {\n      function parse(_x19, _x20, _x21) {\n        return _parse7.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse7.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var def = capture[1].replace(/\\s+/g, \" \").toLowerCase();\n      var target = capture[2];\n      var title = capture[3]; // Look for previous links/images using this def\n      // If any links/images using this def have already been declared,\n      // they will have added themselves to the state._refs[def] list\n      // (_ to deconflict with client-defined state). We look through\n      // that list of reflinks for this def, and modify those AST nodes\n      // with our newly found information now.\n      // Sorry :(.\n\n      if (state._refs && state._refs[def]) {\n        // `refNode` can be a link or an image\n        state._refs[def].forEach(function (refNode) {\n          refNode.target = target;\n          refNode.title = title;\n        });\n      } // Add this def to our map of defs for any future links/images\n      // In case we haven't found any or all of the refs referring to\n      // this def yet, we add our def to the table of known defs, so\n      // that future reflinks can modify themselves appropriately with\n      // this information.\n\n\n      state._defs = state._defs || {};\n      state._defs[def] = {\n        target: target,\n        title: title\n      }; // return the relevant parsed information\n      // for debugging only.\n\n      return {\n        def: def,\n        target: target,\n        title: title\n      };\n    }),\n    react: function react() {\n      return null;\n    },\n    html: function html() {\n      return \"\";\n    }\n  },\n  table: {\n    order: currOrder++,\n    match: blockRegex(TABLES.TABLE_REGEX),\n    parse: TABLES.parseTable,\n    react: function react(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? {} : {\n          textAlign: node.align[colIndex]\n        };\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return reactElement(\"th\", \"\" + i, {\n          style: getStyle(i),\n          scope: \"col\",\n          children: output(content, state)\n        });\n      });\n      var rows = node.cells.map(function (row, r) {\n        return reactElement(\"tr\", \"\" + r, {\n          children: row.map(function (content, c) {\n            return reactElement(\"td\", \"\" + c, {\n              style: getStyle(c),\n              children: output(content, state)\n            });\n          })\n        });\n      });\n      return reactElement(\"table\", state.key, {\n        children: [reactElement(\"thead\", \"thead\", {\n          children: reactElement(\"tr\", null, {\n            children: headers\n          })\n        }), reactElement(\"tbody\", \"tbody\", {\n          children: rows\n        })]\n      });\n    },\n    html: function html(node, output, state) {\n      var getStyle = function getStyle(colIndex) {\n        return node.align[colIndex] == null ? \"\" : \"text-align:\" + node.align[colIndex] + \";\";\n      };\n\n      var headers = node.header.map(function (content, i) {\n        return htmlTag(\"th\", output(content, state), {\n          style: getStyle(i),\n          scope: \"col\"\n        });\n      }).join(\"\");\n      var rows = node.cells.map(function (row) {\n        var cols = row.map(function (content, c) {\n          return htmlTag(\"td\", output(content, state), {\n            style: getStyle(c)\n          });\n        }).join(\"\");\n        return htmlTag(\"tr\", cols);\n      }).join(\"\");\n      var thead = htmlTag(\"thead\", htmlTag(\"tr\", headers));\n      var tbody = htmlTag(\"tbody\", rows);\n      return htmlTag(\"table\", thead + tbody);\n    }\n  },\n  newline: {\n    order: currOrder++,\n    match: blockRegex(/^(?:\\n *)*\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return \"\\n\";\n    },\n    html: function html(node, output, state) {\n      return \"\\n\";\n    }\n  },\n  paragraph: {\n    order: currOrder++,\n    match: blockRegex(/^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"div\", state.key, {\n        className: \"paragraph\",\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        class: \"paragraph\"\n      };\n      return htmlTag(\"div\", output(node.content, state), attributes);\n    }\n  },\n  escape: {\n    order: currOrder++,\n    // We don't allow escaping numbers, letters, or spaces here so that\n    // backslashes used in plain text still get rendered. But allowing\n    // escaping anything else provides a very flexible escape mechanism,\n    // regardless of how this grammar is extended.\n    match: inlineRegex(/^\\\\([^0-9A-Za-z\\s])/),\n    parse: function (_parse8) {\n      function parse(_x22, _x23, _x24) {\n        return _parse8.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse8.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"text\",\n        content: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  tableSeparator: {\n    order: currOrder++,\n    // $FlowFixMe\n    match: function match(source, state) {\n      if (!state.inTable) {\n        return null;\n      }\n\n      return /^ *\\| */.exec(source);\n    },\n    parse: function parse() {\n      return {\n        type: \"tableSeparator\"\n      };\n    },\n    // These shouldn't be reached, but in case they are, be reasonable:\n    react: function react() {\n      return \" | \";\n    },\n    html: function html() {\n      return \" &vert; \";\n    }\n  },\n  autolink: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^: >]+:\\/[^ >]+)>/),\n    parse: function (_parse9) {\n      function parse(_x25, _x26, _x27) {\n        return _parse9.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse9.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1]\n      };\n    }),\n    react: null,\n    html: null\n  },\n  mailto: {\n    order: currOrder++,\n    match: inlineRegex(/^<([^ >]+@[^ >]+)>/),\n    parse: function (_parse10) {\n      function parse(_x28, _x29, _x30) {\n        return _parse10.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse10.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var address = capture[1];\n      var target = capture[1]; // Check for a `mailto:` already existing in the link:\n\n      if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n        target = \"mailto:\" + target;\n      }\n\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: address\n        }],\n        target: target\n      };\n    }),\n    react: null,\n    html: null\n  },\n  url: {\n    order: currOrder++,\n    match: inlineRegex(/^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/),\n    parse: function (_parse11) {\n      function parse(_x31, _x32, _x33) {\n        return _parse11.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse11.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        type: \"link\",\n        content: [{\n          type: \"text\",\n          content: capture[1]\n        }],\n        target: capture[1],\n        title: undefined\n      };\n    }),\n    react: null,\n    html: null\n  },\n  link: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse12) {\n      function parse(_x34, _x35, _x36) {\n        return _parse12.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse12.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var link = {\n        content: parse(capture[1], state),\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return link;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"a\", state.key, {\n        href: sanitizeUrl(node.target),\n        title: node.title,\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        href: sanitizeUrl(node.target),\n        title: node.title\n      };\n      return htmlTag(\"a\", output(node.content, state), attributes);\n    }\n  },\n  image: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp(\"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\\\\(\" + LINK_HREF_AND_TITLE + \"\\\\)\")),\n    parse: function (_parse13) {\n      function parse(_x37, _x38, _x39) {\n        return _parse13.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse13.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      var image = {\n        alt: capture[1],\n        target: unescapeUrl(capture[2]),\n        title: capture[3]\n      };\n      return image;\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"img\", state.key, {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      });\n    },\n    html: function html(node, output, state) {\n      var attributes = {\n        src: sanitizeUrl(node.target),\n        alt: node.alt,\n        title: node.title\n      };\n      return htmlTag(\"img\", \"\", attributes, false);\n    }\n  },\n  reflink: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse14) {\n      function parse(_x40, _x41, _x42) {\n        return _parse14.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse14.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"link\",\n        content: parse(capture[1], state)\n      });\n    }),\n    react: null,\n    html: null\n  },\n  refimage: {\n    order: currOrder++,\n    match: inlineRegex(new RegExp( // The first [part] of the link\n    \"^!\\\\[(\" + LINK_INSIDE + \")\\\\]\" + // The [ref] target of the link\n    \"\\\\s*\\\\[([^\\\\]]*)\\\\]\")),\n    parse: function (_parse15) {\n      function parse(_x43, _x44, _x45) {\n        return _parse15.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse15.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return parseRef(capture, state, {\n        type: \"image\",\n        alt: capture[1]\n      });\n    }),\n    react: null,\n    html: null\n  },\n  em: {\n    order: currOrder\n    /* same as strong/u */\n    ,\n    match: inlineRegex(new RegExp( // only match _s surrounding words.\n    \"^\\\\b_\" + \"((?:__|\\\\\\\\[\\\\s\\\\S]|[^\\\\\\\\_])+?)_\" + \"\\\\b\" + // Or match *s:\n    \"|\" + // Only match *s that are followed by a non-space:\n    \"^\\\\*(?=\\\\S)(\" + // Match at least one of:\n    \"(?:\" + //  - `**`: so that bolds inside italics don't close the\n    //          italics\n    \"\\\\*\\\\*|\" + //  - escape sequence: so escaped *s don't close us\n    \"\\\\\\\\[\\\\s\\\\S]|\" + //  - whitespace: followed by a non-* (we don't\n    //          want ' *' to close an italics--it might\n    //          start a list)\n    \"\\\\s+(?:\\\\\\\\[\\\\s\\\\S]|[^\\\\s\\\\*\\\\\\\\]|\\\\*\\\\*)|\" + //  - non-whitespace, non-*, non-backslash characters\n    \"[^\\\\s\\\\*\\\\\\\\]\" + \")+?\" + // followed by a non-space, non-* then *\n    \")\\\\*(?!\\\\*)\")),\n    quality: function quality(capture) {\n      // precedence by length, `em` wins ties:\n      return capture[0].length + 0.2;\n    },\n    parse: function (_parse16) {\n      function parse(_x46, _x47, _x48) {\n        return _parse16.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse16.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: parse(capture[2] || capture[1], state)\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"em\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"em\", output(node.content, state));\n    }\n  },\n  strong: {\n    order: currOrder\n    /* same as em */\n    ,\n    match: inlineRegex(/^\\*\\*((?:\\\\[\\s\\S]|[^\\\\])+?)\\*\\*(?!\\*)/),\n    quality: function quality(capture) {\n      // precedence by length, wins ties vs `u`:\n      return capture[0].length + 0.1;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"strong\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"strong\", output(node.content, state));\n    }\n  },\n  u: {\n    order: currOrder++\n    /* same as em&strong; increment for next rule */\n    ,\n    match: inlineRegex(/^__((?:\\\\[\\s\\S]|[^\\\\])+?)__(?!_)/),\n    quality: function quality(capture) {\n      // precedence by length, loses all ties\n      return capture[0].length;\n    },\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"u\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"u\", output(node.content, state));\n    }\n  },\n  del: {\n    order: currOrder++,\n    match: inlineRegex(/^~~(?=\\S)((?:\\\\[\\s\\S]|~(?!~)|[^\\s~\\\\]|\\s(?!~~))+?)~~/),\n    parse: parseCaptureInline,\n    react: function react(node, output, state) {\n      return reactElement(\"del\", state.key, {\n        children: output(node.content, state)\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"del\", output(node.content, state));\n    }\n  },\n  inlineCode: {\n    order: currOrder++,\n    match: inlineRegex(/^(`+)([\\s\\S]*?[^`])\\1(?!`)/),\n    parse: function (_parse17) {\n      function parse(_x49, _x50, _x51) {\n        return _parse17.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse17.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[2].replace(INLINE_CODE_ESCAPE_BACKTICKS_R, \"$1\")\n      };\n    }),\n    react: function react(node, output, state) {\n      return reactElement(\"code\", state.key, {\n        children: node.content\n      });\n    },\n    html: function html(node, output, state) {\n      return htmlTag(\"code\", sanitizeText(node.content));\n    }\n  },\n  br: {\n    order: currOrder++,\n    match: anyScopeRegex(/^ {2,}\\n/),\n    parse: ignoreCapture,\n    react: function react(node, output, state) {\n      return reactElement(\"br\", state.key, EMPTY_PROPS);\n    },\n    html: function html(node, output, state) {\n      return \"<br>\";\n    }\n  },\n  text: {\n    order: currOrder++,\n    // Here we look for anything followed by non-symbols,\n    // double newlines, or double-space-newlines\n    // We break on any symbol characters so that this grammar\n    // is easy to extend without needing to modify this regex\n    match: anyScopeRegex(/^[\\s\\S]+?(?=[^0-9A-Za-z\\s\\u00c0-\\uffff]|\\n\\n| {2,}\\n|\\w+:\\S|$)/),\n    parse: function (_parse18) {\n      function parse(_x52, _x53, _x54) {\n        return _parse18.apply(this, arguments);\n      }\n\n      parse.toString = function () {\n        return _parse18.toString();\n      };\n\n      return parse;\n    }(function (capture, parse, state) {\n      return {\n        content: capture[0]\n      };\n    }),\n    react: function react(node, output, state) {\n      return node.content;\n    },\n    html: function html(node, output, state) {\n      return sanitizeText(node.content);\n    }\n  }\n};\n/** (deprecated) */\n\nvar ruleOutput = function ruleOutput( // $FlowFixMe\nrules, property) {\n  if (!property && typeof console !== \"undefined\") {\n    console.warn(\"simple-markdown ruleOutput should take 'react' or \" + \"'html' as the second argument.\");\n  }\n\n  var nestedRuleOutput = function nestedRuleOutput(ast, outputFunc, state) {\n    return rules[ast.type][property](ast, outputFunc, state);\n  };\n\n  return nestedRuleOutput;\n};\n/** (deprecated)\n */\n\n\nvar reactFor = function reactFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      var oldKey = state.key;\n      var result = []; // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n\n      var lastResult = null;\n\n      for (var i = 0; i < ast.length; i++) {\n        state.key = \"\" + i;\n        var nodeOut = nestedOutput(ast[i], state);\n\n        if (typeof nodeOut === \"string\" && typeof lastResult === \"string\") {\n          lastResult = lastResult + nodeOut;\n          result[result.length - 1] = lastResult;\n        } else {\n          result.push(nodeOut);\n          lastResult = nodeOut;\n        }\n      }\n\n      state.key = oldKey;\n      return result;\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n/** (deprecated)\n */\n\n\nvar htmlFor = function htmlFor(outputFunc) {\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || {};\n\n    if (Array.isArray(ast)) {\n      return ast.map(function (node) {\n        return nestedOutput(node, state);\n      }).join(\"\");\n    } else {\n      return outputFunc(ast, nestedOutput, state);\n    }\n  };\n\n  return nestedOutput;\n};\n\nvar outputFor = function outputFor(rules, property) {\n  var defaultState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!property) {\n    throw new Error(\"simple-markdown: outputFor: `property` must be \" + \"defined. \" + \"if you just upgraded, you probably need to replace `outputFor` \" + \"with `reactFor`\");\n  }\n\n  var latestState; // $FlowFixMe[incompatible-type]\n\n  var arrayRule = rules.Array || defaultRules.Array; // Tricks to convince tsc that this var is not null:\n\n  var arrayRuleCheck = arrayRule[property];\n\n  if (!arrayRuleCheck) {\n    throw new Error(\"simple-markdown: outputFor: to join nodes of type `\" + property + \"` you must provide an `Array:` joiner rule with that type, \" + \"Please see the docs for details on specifying an Array rule.\");\n  }\n\n  var arrayRuleOutput = arrayRuleCheck;\n\n  var nestedOutput = function nestedOutput(ast, state) {\n    state = state || latestState;\n    latestState = state;\n\n    if (Array.isArray(ast)) {\n      return arrayRuleOutput(ast, nestedOutput, state);\n    } else {\n      return rules[ast.type][property](ast, nestedOutput, state);\n    }\n  };\n\n  var outerOutput = function outerOutput(ast, state) {\n    latestState = populateInitialState(state, defaultState);\n    return nestedOutput(ast, latestState);\n  };\n\n  return outerOutput;\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultRawParse = parserFor(defaultRules);\n\nvar defaultBlockParse = function defaultBlockParse(source, state) {\n  state = state || {};\n  state.inline = false;\n  return defaultRawParse(source, state);\n};\n\nvar defaultInlineParse = function defaultInlineParse(source, state) {\n  state = state || {};\n  state.inline = true;\n  return defaultRawParse(source, state);\n};\n\nvar defaultImplicitParse = function defaultImplicitParse(source, state) {\n  var isBlock = BLOCK_END_R.test(source);\n  state = state || {};\n  state.inline = !isBlock;\n  return defaultRawParse(source, state);\n}; // $FlowFixMe[incompatible-call]\n\n\nvar defaultReactOutput = outputFor(defaultRules, \"react\"); // $FlowFixMe[incompatible-call]\n\nvar defaultHtmlOutput = outputFor(defaultRules, \"html\");\n\nvar markdownToReact = function markdownToReact(source, state) {\n  return defaultReactOutput(defaultBlockParse(source, state), state);\n};\n\nvar markdownToHtml = function markdownToHtml(source, state) {\n  return defaultHtmlOutput(defaultBlockParse(source, state), state);\n}; // TODO: This needs definition\n\n\nvar ReactMarkdown = function ReactMarkdown(props) {\n  var divProps = {};\n\n  for (var prop in props) {\n    if (prop !== \"source\" && // $FlowFixMe\n    Object.prototype.hasOwnProperty.call(props, prop)) {\n      divProps[prop] = props[prop];\n    }\n  }\n\n  divProps.children = markdownToReact(props.source);\n  return reactElement(\"div\", null, divProps);\n};\n\n// $FlowFixMe\nvar SimpleMarkdown = {\n  defaultRules: defaultRules,\n  parserFor: parserFor,\n  outputFor: outputFor,\n  inlineRegex: inlineRegex,\n  blockRegex: blockRegex,\n  anyScopeRegex: anyScopeRegex,\n  parseInline: parseInline,\n  parseBlock: parseBlock,\n  // default wrappers:\n  markdownToReact: markdownToReact,\n  markdownToHtml: markdownToHtml,\n  ReactMarkdown: ReactMarkdown,\n  defaultBlockParse: defaultBlockParse,\n  defaultInlineParse: defaultInlineParse,\n  defaultImplicitParse: defaultImplicitParse,\n  defaultReactOutput: defaultReactOutput,\n  defaultHtmlOutput: defaultHtmlOutput,\n  preprocess: preprocess,\n  sanitizeText: sanitizeText,\n  sanitizeUrl: sanitizeUrl,\n  unescapeUrl: unescapeUrl,\n  htmlTag: htmlTag,\n  reactElement: reactElement,\n  // deprecated:\n  defaultRawParse: defaultRawParse,\n  ruleOutput: ruleOutput,\n  reactFor: reactFor,\n  htmlFor: htmlFor,\n  defaultParse: function defaultParse() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultParse is deprecated, please use `defaultImplicitParse`\");\n    }\n\n    return defaultImplicitParse.apply(null, arguments);\n  },\n  defaultOutput: function defaultOutput() {\n    if (typeof console !== \"undefined\") {\n      console.warn(\"defaultOutput is deprecated, please use `defaultReactOutput`\");\n    }\n\n    return defaultReactOutput.apply(null, arguments);\n  }\n};\n\nexport { SimpleMarkdown as default };\n//# sourceMappingURL=index.js.map\n","import \"d3\";\nimport { l as log } from \"./commonDb-573409be.js\";\nimport { d as decodeEntities } from \"./mermaidAPI-3ae0f2f0.js\";\nimport SimpleMarkdown from \"@khanacademy/simple-markdown\";\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = withoutMultipleNewlines.replace(/^\\s+/gm, \"\");\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(preprocessedMarkdown);\n  let lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType) {\n    if (node.type === \"text\") {\n      const textLines = node.content.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType || \"normal\" });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.content.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  syntaxTree.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.content.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const mdParse = SimpleMarkdown.defaultBlockParse;\n  const syntaxTree = mdParse(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.content.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.content.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.content.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.content.map(output).join(\"\")}</p>`;\n    } else {\n      return \"\";\n    }\n  }\n  return syntaxTree.map(output).join(\"\");\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `<span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  let bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = -1;\n  structuredText.forEach((line) => {\n    lineIndex++;\n    let tspan = createTspan(textElement, lineIndex, lineHeight);\n    let words = [...line].reverse();\n    let currentWord;\n    let wrappedLine = [];\n    while (words.length) {\n      currentWord = words.pop();\n      wrappedLine.push(currentWord);\n      updateTextContentAndStyles(tspan, wrappedLine);\n      if (tspan.node().getComputedTextLength() > width) {\n        wrappedLine.pop();\n        words.push(currentWord);\n        updateTextContentAndStyles(tspan, wrappedLine);\n        wrappedLine = [];\n        lineIndex++;\n        tspan = createTspan(textElement, lineIndex, lineHeight);\n      }\n    }\n  });\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width,\n  addSvgBackground = false\n} = {}) => {\n  log.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: decodeEntities(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    let vertexNode = addHtmlSpan(el, node, width, classes);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const special = ['\"', \"'\", \".\", \",\", \":\", \";\", \"!\", \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\"];\n    let lastWord;\n    structuredText.forEach((line) => {\n      line.forEach((word) => {\n        if (special.includes(word.content) && lastWord) {\n          lastWord.content += word.content;\n          word.content = \"\";\n        }\n        lastWord = word;\n      });\n    });\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\nexport {\n  createText as c\n};\n//# sourceMappingURL=createText-1f5f8f92.js.map\n"],"names":["CR_NEWLINE_R","TAB_R","FORMFEED_R","preprocess","source","replace","populateInitialState","givenState","defaultState","state","prop","Object","prototype","hasOwnProperty","call","parserFor","rules","latestState","ruleList","keys","filter","type","rule","match","order","isFinite","console","warn","String","sort","typeA","typeB","ruleA","ruleB","orderA","orderB","secondaryOrderA","quality","secondaryOrderB","nestedParse","result","ruleType","capture","NaN","i","currRuleType","currRule","currOrder","prevCaptureStr","prevCapture","currCapture","currQuality","Error","length","index","parsed","parse","Array","isArray","push","apply","concat","substring","outerParse","inline","disableAutoBlockNewlines","inlineRegex","regex","exec","blockRegex","anyScopeRegex","TYPE_SYMBOL","Symbol","for","reactElement","key","props","element","$$typeof","undefined","ref","_owner","htmlTag","tagName","content","attributes","isClosed","attributeString","attr","attribute","sanitizeText","unclosedTag","EMPTY_PROPS","sanitizeUrl","url","prot","URL","protocol","indexOf","e","SANITIZE_TEXT_R","SANITIZE_TEXT_CODES","text","chr","UNESCAPE_URL_R","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","parseBlock","parseCaptureInline","ignoreCapture","LIST_BULLET","LIST_ITEM_PREFIX","LIST_ITEM_PREFIX_R","RegExp","LIST_ITEM_R","BLOCK_END_R","INLINE_CODE_ESCAPE_BACKTICKS_R","LIST_BLOCK_END_R","LIST_ITEM_END_R","LIST_R","LIST_LOOKBEHIND_R","TABLES","TABLE_ROW_SEPARATOR_TRIM","TABLE_CELL_END_TRIM","TABLE_RIGHT_ALIGN","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","parseTableAlignCapture","alignCapture","test","parseTableAlign","trimEndSeparators","alignText","trim","split","map","parseTableRow","prevInTable","inTable","tableRow","cells","forEach","node","parseTableCells","rowsText","rowText","parseTable","header","align","parseNpTable","TABLE_REGEX","NPTABLE_REGEX","LINK_INSIDE","LINK_HREF_AND_TITLE","AUTOLINK_MAILTO_CHECK_R","parseRef","refNode","toLowerCase","_defs","def","target","title","_refs","defaultRules","react","arr","output","oldKey","html","heading","_parse","_x","_x2","_x3","this","arguments","toString","level","children","nptable","lheading","_parse2","_x4","_x5","_x6","hr","codeBlock","_parse3","_x7","_x8","_x9","lang","className","class","fence","_parse4","_x10","_x11","_x12","blockQuote","_parse5","_x13","_x14","_x15","list","isStartOfLineCapture","isListBlock","_list","_parse6","_x16","_x17","_x18","bullet","ordered","start","items","lastItemWasAParagraph","itemContent","item","prefixCapture","space","spaceRegex","isLastItem","containsBlocks","thisItemIsAParagraph","adjustedContent","oldStateInline","oldStateList","ListWrapper","listItems","join","listTag","_parse7","_x19","_x20","_x21","table","getStyle","colIndex","textAlign","headers","style","scope","rows","row","r","c","cols","thead","tbody","newline","paragraph","escape","_parse8","_x22","_x23","_x24","tableSeparator","autolink","_parse9","_x25","_x26","_x27","mailto","_parse10","_x28","_x29","_x30","address","_parse11","_x31","_x32","_x33","link","_parse12","_x34","_x35","_x36","href","image","_parse13","_x37","_x38","_x39","alt","src","reflink","_parse14","_x40","_x41","_x42","refimage","_parse15","_x43","_x44","_x45","em","_parse16","_x46","_x47","_x48","strong","u","del","inlineCode","_parse17","_x49","_x50","_x51","br","_parse18","_x52","_x53","_x54","ruleOutput","property","nestedRuleOutput","ast","outputFunc","reactFor","nestedOutput","lastResult","nodeOut","htmlFor","outputFor","arrayRule","arrayRuleCheck","arrayRuleOutput","outerOutput","defaultRawParse","defaultBlockParse","defaultInlineParse","defaultImplicitParse","isBlock","defaultReactOutput","defaultHtmlOutput","markdownToReact","markdownToHtml","ReactMarkdown","divProps","SimpleMarkdown","defaultParse","defaultOutput","preprocessMarkdown","markdown","withoutMultipleNewlines","withoutExtraSpaces","markdownToLines","preprocessedMarkdown","mdParse","syntaxTree","lines","currentLine","processNode","parentType","textLines","textLine","word","contentNode","treeNode","markdownToHTML","applyStyle","dom","styleFn","addHtmlSpan","width","classes","fo","append","div","label","labelClass","isNode","labelStyle","bbox","getBoundingClientRect","height","createTspan","textElement","lineIndex","lineHeight","createFormattedText","g","structuredText","addBackground","labelGroup","bkg","insert","line","currentWord","tspan","words","reverse","wrappedLine","pop","updateTextContentAndStyles","getComputedTextLength","getBBox","padding","innerTspan","createText","el","isTitle","useHtmlLabels","addSvgBackground","l","htmlText","d","s","vertexNode","special","lastWord","includes","svgLabel"],"sourceRoot":""}